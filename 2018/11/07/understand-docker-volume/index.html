<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;elitegoblin.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Muse&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="Preface在Docker的使用过程中，data persist，share一直是比较令人困惑，比如：   container内部被改动的文件保存在哪里？  container运行结束或者被删除后，如何读取感兴趣的数据？  如何在host及container，container之间共享数据？  本文的目标通过介绍docker相关背景知识(union file system, volume)，给出">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding Docker Volume">
<meta property="og:url" content="https://elitegoblin.github.io/2018/11/07/understand-docker-volume/index.html">
<meta property="og:site_name" content="Frank Sun&#39;s Tech Blog">
<meta property="og:description" content="Preface在Docker的使用过程中，data persist，share一直是比较令人困惑，比如：   container内部被改动的文件保存在哪里？  container运行结束或者被删除后，如何读取感兴趣的数据？  如何在host及container，container之间共享数据？  本文的目标通过介绍docker相关背景知识(union file system, volume)，给出">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-11-07T00:45:05.000Z">
<meta property="article:modified_time" content="2021-05-02T06:09:52.273Z">
<meta property="article:author" content="eliteGoblin">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://elitegoblin.github.io/2018/11/07/understand-docker-volume/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;elitegoblin.github.io&#x2F;2018&#x2F;11&#x2F;07&#x2F;understand-docker-volume&#x2F;&quot;,&quot;path&quot;:&quot;2018&#x2F;11&#x2F;07&#x2F;understand-docker-volume&#x2F;&quot;,&quot;title&quot;:&quot;Understanding Docker Volume&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Understanding Docker Volume | Frank Sun's Tech Blog</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Frank Sun's Tech Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Preface"><span class="nav-number">1.</span> <span class="nav-text">Preface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Where-does-data-reside-in-container"><span class="nav-number">2.</span> <span class="nav-text">Where does data reside in container</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-file-system"><span class="nav-number">3.</span> <span class="nav-text">Docker file system</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Use-bind-to-share"><span class="nav-number">4.</span> <span class="nav-text">Use bind to share</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Persist-and-share-using-volume"><span class="nav-number">5.</span> <span class="nav-text">Persist and share using volume</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clean"><span class="nav-number">6.</span> <span class="nav-text">clean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">7.</span> <span class="nav-text">Conclusion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">8.</span> <span class="nav-text">Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">eliteGoblin</p>
  <div class="site-description" itemprop="description">拒绝复制,经过思考后的总结才属于自己</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/eliteGoblin" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;eliteGoblin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://elitegoblin.github.io/2018/11/07/understand-docker-volume/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="eliteGoblin">
      <meta itemprop="description" content="拒绝复制,经过思考后的总结才属于自己">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frank Sun's Tech Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Understanding Docker Volume
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-07 08:45:05" itemprop="dateCreated datePublished" datetime="2018-11-07T08:45:05+08:00">2018-11-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-05-02 14:09:52" itemprop="dateModified" datetime="2021-05-02T14:09:52+08:00">2021-05-02</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        


<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>在Docker的使用过程中，data persist，share一直是比较令人困惑，比如：</p>
<ul>
<li> container内部被改动的文件保存在哪里？</li>
<li> container运行结束或者被删除后，如何读取感兴趣的数据？</li>
<li> 如何在host及container，container之间共享数据？</li>
</ul>
<p>本文的目标通过介绍docker相关背景知识(union file system, volume)，给出完成常见volume操作的示例，最终达到解答这些问题的目的。</p>
<span id="more"></span>

<h2 id="Where-does-data-reside-in-container"><a href="#Where-does-data-reside-in-container" class="headerlink" title="Where does data reside in container"></a>Where does data reside in container</h2><p>当我们在container中写入数据时，这部分数据保存在哪里呢？</p>
<p>我们首先看一下当前host磁盘容量: </p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br><span class="line">文件系统                     容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                         3.8G     0  3.8G    0% /dev</span><br><span class="line">tmpfs                        766M  2.1M  764M    1% /run</span><br><span class="line">/dev/mapper/ubuntu--vg-root  139G   78G   55G   59% </span><br></pre></td></tr></table></figure>

<p>然后启动一个container，写入size为4G的文件: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ti 交互terminal </span><br><span class="line">docker run --name frank_ubuntu -ti  ubuntu</span><br><span class="line"># 得到container bash</span><br><span class="line">mkdir &#x2F;test_data &amp;&amp; cd &#x2F;test_data</span><br><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;4g.bin bs&#x3D;2G count&#x3D;2</span><br></pre></td></tr></table></figure>

<p>这时再在host运行df -h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件系统                     容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                         3.8G     0  3.8G    0% &#x2F;dev</span><br><span class="line">tmpfs                        766M  2.1M  764M    1% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-root  139G   82G   51G   62% &#x2F;</span><br></pre></td></tr></table></figure>

<p>正如我们所料，新写入的4g.bin占了host上4G的空间，然后停止container：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件系统                     容量  已用  可用 已用% 挂载点</span><br><span class="line">udev                         3.8G     0  3.8G    0% &#x2F;dev</span><br><span class="line">tmpfs                        766M  2.1M  764M    1% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;ubuntu--vg-root  139G   82G   51G   62% &#x2F;</span><br></pre></td></tr></table></figure>

<p>可见虽然停止了container，所占用的磁盘空间仍然存在，如何访问已停止的container呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># i interactive</span><br><span class="line"># a attach STDOUT&#x2F;ERR </span><br><span class="line">docker start -ia frank_ubuntu</span><br></pre></td></tr></table></figure>

<p>为什么要访问已经停止的container的文件呢？典型的应用场景是：运行在container中的service crash，但是需要看已经stop的container存储的log，如果是用 –rm 启动的container，停止后会自动释放磁盘，因为container被remove了，磁盘容量因此会被回收。</p>
<h2 id="Docker-file-system"><a href="#Docker-file-system" class="headerlink" title="Docker file system"></a>Docker file system</h2><p>知道了container写入的文件具有与其相同的生命周期之后，我们来看一看docker的文件系统：</p>
<p>以如下Dockerfile为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN mkdir &#x2F;eg_test_1</span><br><span class="line">RUN mkdir &#x2F;eg_test_2</span><br><span class="line">RUN touch &#x2F;eg_test_2&#x2F;hello_from_frank</span><br></pre></td></tr></table></figure>

<p>查看输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">Step 1&#x2F;4 : FROM ubuntu:18.04</span><br><span class="line"> ---&gt; ea4c82dcd15a                              # lvl 1 标准ubuntu</span><br><span class="line">Step 2&#x2F;4 : RUN mkdir &#x2F;eg_test_1</span><br><span class="line"> ---&gt; Running in 0f2785c298c8</span><br><span class="line">Removing intermediate container 0f2785c298c8</span><br><span class="line"> ---&gt; fb70e5434d03                              # lvl 2 mkdir &#x2F;eg_test_1 </span><br><span class="line">Step 3&#x2F;4 : RUN mkdir &#x2F;eg_test_2</span><br><span class="line"> ---&gt; Running in dd69984f7b67</span><br><span class="line">Removing intermediate container dd69984f7b67       </span><br><span class="line"> ---&gt; 8df2a5f2290e                              # lvl 3 mkdir &#x2F;eg_test_2</span><br><span class="line">Step 4&#x2F;4 : RUN touch &#x2F;eg_test_2&#x2F;hello_from_frank</span><br><span class="line"> ---&gt; Running in 867b28469282</span><br><span class="line">Removing intermediate container 867b28469282</span><br><span class="line"> ---&gt; cdea14636b37                              # lvl 4 touch &#x2F;eg_test_2&#x2F;hello_from_frank</span><br><span class="line">Successfully built cdea14636b37</span><br></pre></td></tr></table></figure>

<p>直观上看到docker构建时是分层的，每一条命令都会改变在前一步成功的基础上增加一层。由Dockerfile build之后的image由一系列的read-only层组成，最上面是一个read-write层，container运行起来之后，对文件系统做的改动，写入的数据等均会保存在最上面的读写层。</p>
<blockquote>
<p>docker image格式：自底向上，由一系列只读层，加上最上面的读写层，称之为Union File System</p>
</blockquote>


<p>当container被删除后，再重新启动同样的image，会在最上面构建一个全新的读写层，之前container的数据被丢弃。</p>
<p>Union File System 并不能与外界(宿主机，NFS)共享file/directory，以及分离数据与container的生命周期，如何解决？简单的bind机制应运而生。</p>
<h2 id="Use-bind-to-share"><a href="#Use-bind-to-share" class="headerlink" title="Use bind to share"></a>Use bind to share</h2><p>何为bind? 将host的file/directory与container共享，任何一方的修改都对对方立刻可见。bind命令可能大家并不陌生</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将host的&#x2F;tmp directory mount到container的&#x2F;host_tmp directory</span><br><span class="line">sd run -ti -v &#x2F;tmp:&#x2F;host_tmp --name frank_ubuntu --rm ubuntu</span><br></pre></td></tr></table></figure>

<p>运行bind后，查看此container的Mounts选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect eager_cray -f &#39;&#123;&#123;json .Mounts&#125;&#125;&#39; | jq</span><br></pre></td></tr></table></figure>

<p>注: jq是一个很好用的Command-line JSON processor，安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install jq</span><br></pre></td></tr></table></figure>

<p>可以看到Type, source, destination</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;bind&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/tmp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/eg_tmp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>另外：官方建议大家使用–mount option，避免-v src:dst 时bind和volume弄混的pitfall，虽然繁琐一点，但是清晰可读大于一切。接下来的例子，将尽量采用建议的做法，因为之前自己也被-v的灵活语法弄得很是混乱，而且对理解概念没有帮助。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker官方建议使用mount option，更verbose</span><br><span class="line">docker run -it --rm --name frank_ubuntu\</span><br><span class="line">  --mount type&#x3D;bind,source&#x3D;&#x2F;tmp,target&#x3D;&#x2F;eg_tmp\</span><br><span class="line">  ubuntu:18.04</span><br></pre></td></tr></table></figure>

<p>这样container只要将想persist的数据写入与host bind的mount point，就可以同时实现与host数据共享以及生命周期分离。</p>
<p>这样做非常方便，我们在build image后，运行docker时指定要挂载的host file/folder即可。开发自己docker container管理系统的同学一定熟悉类似的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock portainer&#x2F;portainer</span><br></pre></td></tr></table></figure>

<p>这是bind的一个典型用法：将host的docker daemon的unix sock文件，共享给了某个container，这样此container就可以通过读写本container的docker.sock文件，来调用host的docker API，实现host的container环境的管理了。</p>
<p>bind的一些典型用法: </p>
<ul>
<li> 在host与container之间共享配置，例如container bind host的/etc/resolv.conf,实现DNS</li>
<li> 共享source code及release file，方便container运行</li>
</ul>
<p>借助bind，实现了数据快速共享及persist，但这是在借助host的文件系统而实现的，有没有更通用的共享方案呢？于是就引出了Volume。</p>
<h2 id="Persist-and-share-using-volume"><a href="#Persist-and-share-using-volume" class="headerlink" title="Persist and share using volume"></a>Persist and share using volume</h2><p>先看下两段官方描述: </p>
<blockquote>
<p>volumes are managed by Docker and are isolated from the core functionality of the host machine. A given volume can be mounted into multiple containers simultaneously. When no running container is using a volume, the volume is still available to Docker and is not removed automatically.</p>
</blockquote>
<blockquote>
<p>A data volume is a specially-designated directory within one or more containers that bypasses the Union File System. </p>
</blockquote>
<p>我们先直观的感受一下volume: </p>
<p>创建一个名为 frank_test_vol 的volume</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker volume create frank_test_vol</span><br><span class="line"># 查看当前host上volume</span><br><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>
<p>可以看到刚刚创建的volume</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               frank_test_vol</span><br></pre></td></tr></table></figure>

<p>查看volume详细信息: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect frank_test_vol | jq</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2018-11-10T10:33:31+11:00&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Labels&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/frank_test_vol/_data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;frank_test_vol&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>发现Mountpoint在host上的一个路径，这里volume存储在host上:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ls -l &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;frank_test_vol&#x2F;</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 3 root root  4096 11月 10 10:33 frank_test_vol</span><br></pre></td></tr></table></figure>

<p>如何使用这个volume呢：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm --name frank_ubuntu \</span><br><span class="line">--mount source&#x3D;frank_test_vol,target&#x3D;&#x2F;my_vol \</span><br><span class="line">ubuntu</span><br></pre></td></tr></table></figure>

<p>这个命令–mount是在runtime将已经建立的volume mount到container的/my_vol处，而真正存储是在host的/var/lib/docker/volumes/frank_test_vol/</p>
<p>可以查看container的mount信息感受一下与bind的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123;json .Mounts&#125;&#125;&#39; frank_ubuntu</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;frank_test_vol&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/frank_test_vol/_data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/my_vol&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以看到Type是volume而不是之前的bind，同样能看到mount的source和destination信息</p>
<p>目录，这样共享就完成了，而且任何一方对volume的改动都会被对方立刻看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># in container</span><br><span class="line">touch &#x2F;my_vol&#x2F;hello_from_container</span><br><span class="line"># in host</span><br><span class="line">sudo touch &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;frank_test_vol&#x2F;_data&#x2F;hello_from_host</span><br></pre></td></tr></table></figure>

<p>查看host/container上的对应目录，均会发现两个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r-- 1 root root    0 Nov 10 00:15 hello_from_container</span><br><span class="line">-rw-r--r-- 1 root root    0 Nov 10 00:15 hello_from_host</span><br></pre></td></tr></table></figure>

<p>可能你会问，假如container运行时想mount到某处，可以image在此处已经有entry，或者说有folder/file存在，会怎么样？ 答案就是会覆盖image的，以运行时挂载的为准。</p>
<p>我们可以看到，volume是独立于container而创建和manage的，container可以在运行时mount volume，而且此volume可以同时mount到多个container</p>
<p>总结一下，volume有如下feature: </p>
<ul>
<li> 跨平台，支持windows和linux</li>
<li> Volume本身bypass了Union File System</li>
<li> Data volumes can be shared and reused among containers</li>
<li> Changes to a data volume are made directly</li>
<li> Changes to a data volume will not be included when you update an image</li>
<li> Data volumes persist even if the container itself is deleted</li>
<li> Volume drivers let you store volumes on remote hosts or cloud providers, to encrypt the contents of volumes, or to add other functionality.</li>
<li> New volumes can have their content pre-populated by a container(下面会谈到)</li>
</ul>
<p>如果container有想独立于image的数据，可以将其存储于volume上，就像独立的u盘，于自己独立，而且可以很方便的与他人分享。</p>
<p>那这样每次我们想使用volume得先在命令行创建volume，再在runtime通过命令行参数绑定此volume，步骤比较繁琐。有时我们需要container运行起来，自动创建其container独有的volume，存放此次运行的log, data。这时匿名volume就会非常有帮助。</p>
<p>volume分为named和anonymous两种，区别是named就像我们之前演示的那样，我们手动创建，并赋予其name，而anonymous是在container运行时pre-populated，也就是自动创建的，并非没有名字，而是一串保证不会重复的随机串作为其名字，既然想自动化，而非命令行手动创建并在docker run时mount，那就需要我们记录在Dockerfile中，这就是Dockerfile的VOLUME命令出现的原因: </p>
<p>如下Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN mkdir &#x2F;my_tmp&#x2F;</span><br><span class="line">RUN mkdir &#x2F;my_tmp&#x2F;eg_test_1</span><br><span class="line">RUN mkdir &#x2F;my_tmp&#x2F;eg_test_2</span><br><span class="line">RUN touch &#x2F;my_tmp&#x2F;eg_test_2&#x2F;hello_from_frank</span><br><span class="line"></span><br><span class="line">VOLUME &#x2F;my_tmp</span><br><span class="line"></span><br><span class="line">RUN touch &#x2F;my_tmp&#x2F;eg_test_2&#x2F;should_not_in_volume</span><br></pre></td></tr></table></figure>
<p>VOLUME命令会干3件事: </p>
<ul>
<li> 创建一个匿名volume</li>
<li> 拷贝 container <strong>当前</strong> /my_tmp位置的内容到此匿名volume</li>
<li> mount volume到container的/my_tmp位置</li>
</ul>
<p>build并运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t frank&#x2F;ubuntu .</span><br><span class="line">docker run -ti --rm --name frank_ubuntu frank&#x2F;ubuntu</span><br></pre></td></tr></table></figure>

<p>查看系统volume会发现匿名volume</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               16b77fc36729cf3bcd0f37270f5cd4dd13cae7b4026ad1562dfd461104a289a8</span><br></pre></td></tr></table></figure>

<p>inspect container, 仅显示Mounts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#39;&#123;&#123;json .Mounts&#125;&#125;&#39; frank_ubuntu | jq</span><br></pre></td></tr></table></figure>

<p>得到</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;volume&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;16b77fc36729cf3bcd0f37270f5cd4dd13cae7b4026ad1562dfd461104a289a8&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Source&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/16b77fc36729cf3bcd0f37270f5cd4dd13cae7b4026ad1562dfd461104a289a8/_data&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Destination&quot;</span>: <span class="string">&quot;/my_tmp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mode&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;RW&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;Propagation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>我们可以看到volume在host上存储的位置，如果查看会发现docker image中建立的文件/文件夹已经被加入到新建立的匿名卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;9cf0b9e60303d021796ee4fa2c661e8287fcfab43257bcd6d7ffe3c9a07717ba&#x2F;_data&#x2F;</span><br><span class="line">├── eg_test_1</span><br><span class="line">└── eg_test_2</span><br><span class="line">    └── hello_from_frank</span><br></pre></td></tr></table></figure>

<p>但是并没有 /my_tmp/eg_test_2/should_not_in_volume，在我们的Dockerfile中，此文件是在Volume命令之后加入到docker image的，因为docker构建时顺序执行，这时自然不会将还没有建立的文件拷贝到匿名volume中。</p>
<p>用docker命令行–mount也可以达到一样的效果</p>
<p>去掉上面Dockerfile的VOLUME命令: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN mkdir &#x2F;my_tmp&#x2F;</span><br><span class="line">RUN mkdir &#x2F;my_tmp&#x2F;eg_test_1</span><br><span class="line">RUN mkdir &#x2F;my_tmp&#x2F;eg_test_2</span><br><span class="line">RUN touch &#x2F;my_tmp&#x2F;eg_test_2&#x2F;hello_from_frank</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm --name frank_ubuntu --mount type&#x3D;volume,target&#x3D;&#x2F;my_tmp</span><br></pre></td></tr></table></figure>

<p>和VOLUME效果一样，先创建一个空匿名Volume，如果mount的target不存在，创建一个空folder；如果存在，则把当前存在的内容拷贝至创建的Volume中。</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>最后我们清理一下刚才测试过程中产生的垃圾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 测试环境无所谓，干活时慎重使用!</span><br><span class="line">docker system prune</span><br><span class="line"># 清理没有attach的volume，</span><br><span class="line">docker volume rm &#96;docker volume ls -q -f dangling&#x3D;true&#96;</span><br><span class="line"># 或者</span><br><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文从container数据持久化说起，引出bind: share host及container folder；之后提到更通用的方案: volume；有两种类型的volume: named及anonymous; 对于anonymous volume，两种使用方式： cmdline及Dockerfile的Volume指令。</p>
<ul>
<li> bind用在简单共享文件，配置，源代码</li>
<li> 仅想expose, persist container的数据(如程序log)，anonymous volume是首选，最方便的是Dockerfile的VOLUME命令，每次启动container会自动创建匿名volume</li>
<li> docker rm –rm 选项会删除随container创建的匿名volume</li>
<li> 尽量用–mount而非-v选项，-v选项几种支持的模式语法上很模糊，容易混淆。</li>
<li> volume是存储的抽象，对container提供了同样的访问接口。不仅支持存放在host的文件系统，也支持NFS等。</li>
</ul>
<p>常见的Volume命令总结:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-vol</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect my-vol</span><br><span class="line">docker run -ti\</span><br><span class="line">  --name frank_ubuntu \</span><br><span class="line">  --mount source&#x3D;myvol2,target&#x3D;&#x2F;app \</span><br><span class="line">  ubuntu:18.04</span><br><span class="line">sd inspect frank_ubuntu -f &#39;&#123;&#123;json .Mounts&#125;&#125;&#39; | jq</span><br><span class="line">docker system prune</span><br><span class="line">docker volume prune</span><br></pre></td></tr></table></figure>



<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/">Manage data in Docker</a><br><a target="_blank" rel="noopener" href="https://container-solutions.com/understanding-volumes-docker/">Understanding Volumes in Docker</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/bind-mounts/">Use bind mounts</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/volumes/">Use volumes</a><br><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a><br><a target="_blank" rel="noopener" href="https://yeasy.gitbooks.io/docker_practice/image/dockerfile/volume.html">VOLUME 定义匿名卷</a>  </p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/10/14/setup-docker-as-VMs/" rel="prev" title="setup docker as 'VMs'">
                  <i class="fa fa-chevron-left"></i> setup docker as 'VMs'
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/11/12/Setuid-how-to-act-as-another-user-in-a-process/" rel="next" title="Setuid in Linux File Permission">
                  Setuid in Linux File Permission <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">eliteGoblin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
